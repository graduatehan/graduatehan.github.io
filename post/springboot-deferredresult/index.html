<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>SpringBoot 异步处理—— DeferredResult | 白熊 Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="1. 背景 工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。
2. DeferredResult 简介 DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，释放 Servlet 容器（如 Tomcat 容器、Undertow 容器等）线程。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。
对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。
3. DeferredResult 应用实验 3.1 实验代码 请求处理 Service 如下，模拟 2s 的请求处理耗时
@Service public class MyService { public String process() { try { // 模拟请求处理耗时 2s TimeUnit.SECONDS.sleep(2); } catch (Exception ignored) { } return &#34;success&#34;; } } 同步接口调用 Service 方法">
    <meta name="generator" content="Hugo 0.120.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="https://graduatehan.github.io/post/springboot-deferredresult/">
    

    <meta property="og:title" content="SpringBoot 异步处理—— DeferredResult" />
<meta property="og:description" content="1. 背景 工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。
2. DeferredResult 简介 DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，释放 Servlet 容器（如 Tomcat 容器、Undertow 容器等）线程。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。
对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。
3. DeferredResult 应用实验 3.1 实验代码 请求处理 Service 如下，模拟 2s 的请求处理耗时
@Service public class MyService { public String process() { try { // 模拟请求处理耗时 2s TimeUnit.SECONDS.sleep(2); } catch (Exception ignored) { } return &#34;success&#34;; } } 同步接口调用 Service 方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://graduatehan.github.io/post/springboot-deferredresult/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-11-25T08:59:58+08:00" />
<meta property="article:modified_time" content="2023-11-25T08:59:58+08:00" />

<meta itemprop="name" content="SpringBoot 异步处理—— DeferredResult">
<meta itemprop="description" content="1. 背景 工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。
2. DeferredResult 简介 DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，释放 Servlet 容器（如 Tomcat 容器、Undertow 容器等）线程。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。
对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。
3. DeferredResult 应用实验 3.1 实验代码 请求处理 Service 如下，模拟 2s 的请求处理耗时
@Service public class MyService { public String process() { try { // 模拟请求处理耗时 2s TimeUnit.SECONDS.sleep(2); } catch (Exception ignored) { } return &#34;success&#34;; } } 同步接口调用 Service 方法"><meta itemprop="datePublished" content="2023-11-25T08:59:58+08:00" />
<meta itemprop="dateModified" content="2023-11-25T08:59:58+08:00" />
<meta itemprop="wordCount" content="405">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SpringBoot 异步处理—— DeferredResult"/>
<meta name="twitter:description" content="1. 背景 工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。
2. DeferredResult 简介 DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，释放 Servlet 容器（如 Tomcat 容器、Undertow 容器等）线程。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。
对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。
3. DeferredResult 应用实验 3.1 实验代码 请求处理 Service 如下，模拟 2s 的请求处理耗时
@Service public class MyService { public String process() { try { // 模拟请求处理耗时 2s TimeUnit.SECONDS.sleep(2); } catch (Exception ignored) { } return &#34;success&#34;; } } 同步接口调用 Service 方法"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        白熊 Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">SpringBoot 异步处理—— DeferredResult</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-11-25T08:59:58+08:00">November 25, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="1-背景">1. 背景</h2>
<p>工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。</p>
<h2 id="2-deferredresult-简介">2. DeferredResult 简介</h2>
<p>DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，<strong>释放 Servlet 容器</strong>（如 Tomcat 容器、Undertow 容器等）<strong>线程</strong>。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。</p>
<p>对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。</p>
<h2 id="3-deferredresult-应用实验">3. DeferredResult 应用实验</h2>
<h3 id="31-实验代码">3.1 实验代码</h3>
<p>请求处理 Service 如下，模拟 2s 的请求处理耗时</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyService</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">process</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 模拟请求处理耗时 2s</span>
</span></span><span style="display:flex;"><span>            TimeUnit.<span style="color:#a6e22e">SECONDS</span>.<span style="color:#a6e22e">sleep</span>(2);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (Exception ignored) {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;success&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同步接口调用 Service 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Resource</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> MyService myService;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@GetMapping</span>(<span style="color:#e6db74">&#34;/sync&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">sync</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> myService.<span style="color:#a6e22e">process</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用 DeferredResult 的异步接口调用 Service 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@GetMapping</span>(<span style="color:#e6db74">&#34;/async&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> DeferredResult<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">async</span>() {
</span></span><span style="display:flex;"><span>    DeferredResult<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> deferredResult <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DeferredResult<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将请求处理委托给线程池</span>
</span></span><span style="display:flex;"><span>    deferredProcess(executorService, myService::process, deferredResult, <span style="color:#e6db74">&#34;asyncMethod&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> deferredResult;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 异步处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param executor 执行请求处理任务的线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param supplier 要执行的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param deferredResult deferredResult对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param interfaceName 接口名，用于监控上报和日志打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param &lt;T&gt; 执行方法的返回值泛型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deferredProcess</span>(ExecutorService executor, Supplier<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> supplier, DeferredResult<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> deferredResult,
</span></span><span style="display:flex;"><span>        String interfaceName) {
</span></span><span style="display:flex;"><span>    executor.<span style="color:#a6e22e">submit</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> startTime <span style="color:#f92672">=</span> System.<span style="color:#a6e22e">currentTimeMillis</span>();
</span></span><span style="display:flex;"><span>            T result <span style="color:#f92672">=</span> supplier.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 设置正常返回结果</span>
</span></span><span style="display:flex;"><span>            deferredResult.<span style="color:#a6e22e">setResult</span>(result);
</span></span><span style="display:flex;"><span>            logger.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;{} spend {} ms&#34;</span>, interfaceName, System.<span style="color:#a6e22e">currentTimeMillis</span>() <span style="color:#f92672">-</span> startTime);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>            logger.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;{} error e:&#34;</span>, interfaceName, e);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 设置异常返回结果</span>
</span></span><span style="display:flex;"><span>            deferredResult.<span style="color:#a6e22e">setErrorResult</span>(e.<span style="color:#a6e22e">getMessage</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="32-手动单次调用">3.2 手动单次调用</h3>
<p>同步接口调用，耗时 2.023s</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082205955.png" alt="image-20230608下午100546908"></p>
<p>服务日志：</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082107485.png" alt=""></p>
<p>异步接口调用，耗时 2.034s</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082207521.png" alt="image-20230608下午100755474"></p>
<p>服务日志：</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082111734.png" alt="image-20230608下午91123691"></p>
<p>从日志第五列（线程名称）中可以看到，调用同步接口期间，Tomcat 容器线程一直在工作。 调用异步接口期间，Tomcat容器线程被释放。</p>
<h3 id="33-使用-jmeter-压测">3.3 使用 Jmeter 压测</h3>
<p>引入 没有逻辑的 alive 接口，测试请求高并发时，同步接口和异步接口对服务提供的其他接口的影响</p>
<pre tabindex="0"><code>@GetMapping(&#34;/alive&#34;)
public String alive() {
    return &#34;alive&#34;;
}
</code></pre><p>application.yaml 配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">server</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">tomcat</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">max-threads</span>: <span style="color:#ae81ff">10</span> <span style="color:#75715e"># 设置 Tomcat 容器最大线程数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">debug</span>: <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>设置对照实验：</p>
<p>实验一：使用 50 个线程并发访问 sync 接口 200次，同时使用 50 个线程并发访问 alive 接口 200次</p>
<p>实验二：使用 50 个线程并发访问 async 接口 200次，同时使用 50 个线程并发访问 alive 接口 200次</p>
<p>各接口测试聚合报告如下：</p>
<p>实验一 sync 接口测试聚合报告</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082146066.png" alt="image-20230608下午94644021"></p>
<p>实验一 alive接口测试聚合报告</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082147659.png" alt="image-20230608下午94706622"></p>
<p>实验二 async 接口测试聚合报告</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082142043.png" alt="image-20230608下午94244993"></p>
<p>实验二 alive 接口测试聚合报告</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306082143735.png" alt="image-20230608下午94324681"></p>
<p>为了更加直观的展示结果，从聚合报告中选择平均耗时、最小耗时、最大耗时三个指标汇总如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>平均耗时（ms）</th>
<th>最小耗时（ms）</th>
<th>最大耗时（ms）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实验一 sync 接口</td>
<td>8668</td>
<td>2004</td>
<td>12047</td>
</tr>
<tr>
<td>实验一 alive 接口</td>
<td>8846</td>
<td>1</td>
<td>10051</td>
</tr>
<tr>
<td>实验二 async 接口</td>
<td>2020</td>
<td>2003</td>
<td>2046</td>
</tr>
<tr>
<td>实验二 alive 接口</td>
<td>45</td>
<td>0</td>
<td>149</td>
</tr>
</tbody>
</table>
<p>可以看出，相同的请求量和并发量，异步接口的耗时表现明显优于同步接口，对服务其他接口的影响异步接口同样明显优于同步接口。异步接口在请求到达和返回结果时，毕竟也使用了 Tomcat 容器线程，所以并发量大时，对其他接口还是有影响，但影响明显小于同步接口的影响。</p>
<h2 id="4-deferredresult-请求处理流程分析">4. DeferredResult 请求处理流程分析</h2>
<p>一次 DeferredResult 接口调用日志如下：</p>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306092018527.png" alt="image-20230609下午73549575"></p>
<p>结合日志，分析 DeferredResult 请求处理如下：</p>
<ol>
<li>客户端发送请求到 DispatchServlet （日志第 1 行）</li>
<li>通过映射器处理器 HandlerMapping 找到对应的控制器 Controller 方法 （日志第 2 行）</li>
<li>反射调用控制器方法处理请求（日志第 3-4 行）</li>
<li>根据控制器方法返回值类型，调用相应的 ReturnValueHandler。通过代码调试可以看到，对于 DeferredResult 返回值类型，调用的 ReturnValueHandler  为 DeferredResultMethodReturnValueHandler</li>
</ol>
<p><img src="https://paper-picture-1302544412.cos.ap-beijing.myqcloud.com/pic/202306092011486.png" alt="image-20230609下午81146426"></p>
<ol start="5">
<li>DeferredResultMethodReturnValueHandler 中 handleReturnValue 方法 会获取 请求的 WebAsyncManager 并调用 WebAsyncManager 的 startDeferredResultProcessing 方法，开启异步处理。此时容器线程释放，但客户端请求链接没有释放（日志第 5 行）</li>
<li>自定义线程处理完请求后，调用 deferredResult 的 setResult 方法，setResult 方法 中会回调 在 WebAsyncManager 设置的 resultHandler 方法（日志第 7-9 行）</li>
<li>resultHandler 方法会将请求结果存在 WebAsyncManager 的 concurrentResult 属性中，并重新触发 dispatch （此时 Tomcat 线程 已经和 之前请求使用Tomcat 线程 不是同一个了）。</li>
<li>请求再次进来时，WebAsyncManager 的 concurrentResult 属性中已经存在请求响应结果（日志第 11 行）</li>
<li>不再反射调用控制器方法，将响应结果返回给客户端</li>
</ol>
<h2 id="5-总结">5. 总结</h2>
<p>简单总结，SpringBoot 的 Controller 方法返回值如果为 DeferredResult 类型，则不会把返回值作为响应返回给调用方，容器线程会被释放，DeferredResult 设置结果后，设置的结果才会作为响应返回给调用方。</p>
<p>实现原理为，每一次请求都对应一个唯一的 WebAsyncManager 对象，DeferredResult 的  setResult 方法调用后，响应结果缓存在了 WebAsyncManager 中，同时会再次触发 doDispatch 方法。再次触发请求时，发现 WebAsyncManager 已经存在响应结果，会直接返回响应结果。</p>
<p>最后，感谢阅读，如果有写的不妥的地方，欢迎评论区批评指正。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://graduatehan.github.io/" >
    &copy;  白熊 Blog 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
