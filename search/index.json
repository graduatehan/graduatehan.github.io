[{"content":"1. HUGO 安装 官网：https://gohugo.io/installation/windows/\n下述已 Windows 为例，其他系统类似。\n1.1 版本 有两个版本：standard and extended\n扩展版（extended）功能更强大，推荐安装。\n1.2 安装方式 二进制安装包（推荐，最简单） 下载地址：https://github.com/gohugoio/hugo/releases/latest 根据操作系统选择对应版本即可，如 hugo_extended_0.120.4_windows-amd64.zip 包管理器安装，例如 Winget，略 源码编译，略 2. 使用前的准备工作 2.1 Hugo 添加环境变量 下载安装包解压即可使用，将解压路径添加到环境变量。例如：D:\\hugo_extended_0.120.4_windows-amd64\n2.2 Git 安装及设置 2.2.1 下载安装 官网下载 https://git-scm.com/downloads 使用包管理器下载 2.2.2 配置 1 2 3 4 5 6 7 8 9 10 11 # 配置用户名以及邮箱 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;邮箱\u0026#34; # 查看是否配置成功 git config --global --list # 生成密钥（默认生成 ~/.ssh 目录下），用于免密连接 github ssh-keygen -t rsa -C \u0026#34;邮箱\u0026#34; # 登录github -\u0026gt;进入设置-\u0026gt;SSH and GPG key -\u0026gt;新建密钥，将id_rsa.pub内容复制并保存 # 测试连接 ssh -T git@github.com 2.3 提醒 如果使用 Windows :\n请勿使用 cmd or Windows PowerShell 执行下面命令。 可以使用 git bash or PowerShell 注： PowerShell and Windows PowerShell are different applications.\n3. 使用 HUGO 创建博客 官网指导文档： https://gohugo.io/getting-started/quick-start/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 创建站点,指定站点名 my_blog hugo new site my_blog # 进入目录 cd my_blog # 初始化 git git init # 选择喜欢的主题，主题下载地址：https://themes.gohugo.io/ # ananke主题，拉取远程仓库主题 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke # 设置 使用主题 ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml # 本地预览效果 hugo server # 添加文章， 注意必须在 posts 文件夹下【主题约定博客目录】 hugo new posts/myfirstpost.md # 生成到 content/posts 文件夹下 # 编译生成静态网站 生成 public 文件夹 hugo 4. 部署（托管）到 GitHub 创建公开仓库，仓库名：用户名.github.io [必须] 创建 Git 子模块， 将 public 文件夹下内容 push 到 GitHub 仓库 1 2 3 4 5 6 git submodule add git@github.com:用户名/用户名.github.io.git public cd public git add . git commit -m \u0026#34;first commit\u0026#34; git push origin master 浏览器访问：https://graduatehan.github.io/ 5. 另建私有 GitHub 仓库：my_blog 将所有内容交给 Git 管理，并 push 到 GitHub 仓库\n编辑.gitignore 文件：\n1 2 resources/* .hugo_build.lock .gitmodules 文件：\n无需编辑文件，使用 git submodule add 命令添加 1 2 3 4 5 6 [submodule \u0026#34;themes/ananke\u0026#34;] path = themes/ananke url = https://github.com/theNewDynamic/gohugo-theme-ananke.git [submodule \u0026#34;public\u0026#34;] path = public url = git@github.com:用户名/用户名.github.io.git ","date":"2023-11-25T10:47:08+08:00","permalink":"https://graduatehan.github.io/p/hello-hugo/","title":"Hello Hugo"},{"content":"1. 引言 1.1 工作中遇到场景 将运营同学给的名单转成Json列表格式 遇到特殊情况需要做MDL 1.2 解决方式：多行编辑 以转Json列表格式为例\n1.2.1 全文编辑器 sublime text ：多行编辑快捷键\n快捷键： cmd+A -\u0026gt; shift+cmd+L -\u0026gt; \u0026quot; -\u0026gt; cmd+右箭头 -\u0026gt; , 解释： 选中全部 -\u0026gt; 光标定位到选中行(选中状态) -\u0026gt; 选中文本加引号 -\u0026gt; 光标定位到行尾 -\u0026gt; 插入逗号 vim ： 宏录制重放\n录制 : qa -\u0026gt; I -\u0026gt; \u0026quot; -\u0026gt; esc -\u0026gt; A -\u0026gt; \u0026quot;,-\u0026gt; esc -\u0026gt;q 解释：开启录制 -\u0026gt; 行首插入 -\u0026gt; 引号 -\u0026gt; 返回normal模式 -\u0026gt; 行尾插入 -\u0026gt; 引号逗号 -\u0026gt; 返回normal模式 -\u0026gt; 结束录制 回放：V -\u0026gt; G -\u0026gt; : -\u0026gt; normal @a 解释：选中光标行进入可视行模式 -\u0026gt; 选中至文尾 -\u0026gt; 单行命令模式 -\u0026gt; 重放宏 其他文本编辑器。。。\n1.2.2 行编辑器 awk ： 非交互式命令，awk '{print \u0026quot;\\\u0026quot;\u0026quot;$0\u0026quot;\\\u0026quot;,\u0026quot;}' companyName.txt sed ： 非交互式命令，sed 's/^/\u0026quot;/;s/$/\u0026quot;,/' companyName.txt 1.2.3 比较 数据量达到1w行，sublime 已经开始卡顿；数据量到10w行 ，sublime直接卡死\n数据量到100w行，awk，sed毫无压力，耗时分别为0.5s 和 0.18s\n说明：seq命令生成数字序列，模拟需要处理的数据\n数据量到100w行，vim虽然比awk、sed慢，但还是能处理！牛！（这里不展开讲vim）\n1.3 需求再次变化 1.3.1 把Json列表格式转换成1行 可以在上面命令基础上， 使用tr命令 可以用awk命令指定输出记录分隔符 1.3.2 最后这个逗号也不想要，咋办 可以用sed命令把最后一个字符删掉 1.3.3 能不能只用sed or awk命令 答案： 能！ 1 2 seq 10 | awk \u0026#39;{s=s\u0026#34;\\\u0026#34;\u0026#34;$0\u0026#34;\\\u0026#34;,\u0026#34;} END{sub(\u0026#34;.$\u0026#34;, \u0026#34;\u0026#34;, s);print s}\u0026#39; seq 10 | sed -n \u0026#39;s/^/\u0026#34;/;s/$/\u0026#34;/;1h;1!H;${x;s/\\n/,/g;p}\u0026#39; 上面的命令能不能看懂？不能？ 本文目标就是让大家能看懂上面命令！\n2. 行编辑器介绍 2.1 sed用法介绍 简介 sed 可依照脚本的指令来处理、编辑文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。\nsed的工作方式\n从文件或者标准输入(input stream)中读取一行到模式空间（pattern space）中 一系列指令处理输入行(指令中可能用到保持空间hold space) 把处理结果输出到标准输出 重复执行step1~step3，直到输入处理完毕 语法：sed [-nri] [-e\u0026lt;script\u0026gt;] [-f\u0026lt;script文件\u0026gt;] [文本文件]\n-n 静默模式（处理完毕不输出），一般和p连用 -r 支持扩展正则表达式（扩展元字符eg：+?| ） -i 修改会保存到原文件 script 指令格式 ： [寻址] 指令\n[寻址]\n可为空表示不寻址，每行都处理 支持行号 和 正则 可以混用 number 行号 first~step 从第first行开始处理，每step行处理一次 例如： 1~2 处理奇数行 /regexp/ 正则匹配 /regexp/,/regexp/ 正则匹配一个范围 0,addr2 行号匹配一个范围 addr1,+N 匹配addr1行及其后面的N行 [寻址]! 表示对寻址取反 指令\nsed '[寻址]s/key/newkey/[标志位]' 替换指令 寻址为空表示全部匹配 对匹配行执行替换指令 标志位 空：表示替换第一次出现 数字： 替换第几次出现 p： 打印，配合 -n 使用 w file ： 将模式空间内容写到文件file中 sed '[寻址]p' 打印匹配行 实际应用举例 截取一段时间内日志：sed -n '/2023-03-29 21:00:00 +0800/,/2023-03-29 21:10:00 +0800/p' application.log \u0026gt; demo.log 截取指定行数日志 ：sed -n '10000,20000p' application.log \u0026gt; demo.log sed '[寻址]d' 删除匹配行 sed '[寻址]a message' 行后追加message sed '[寻址]i message' 行前追加message sed '[寻址]c message' 用message取代整行 sed '[寻址]q' 退出sed sed '[寻址]=' 输出行号 sed '[寻址]w file' 写入文件 sed '[寻址]r file' 读出文件 。。。 多行模式相关指令\nN 将下一行加入模式空间 D 删除模式空间中第一个字符到第一个换行符 P 打印模式空间中第一个字符到第一个换行符 保持空间（hold space）相关指令\nh和H将模式空间内容存放到保持空间 h：覆盖模式 H：追加模式 g和G将保持空间内容取出到模式空间 g：覆盖模式 G：追加模式 x 交换保持空间和模式空间的内容 sed语法详见sed用户手册man sed\n2.2 引言中sed命令解析 seq 10 | sed -n 's/^/\u0026quot;/;s/$/\u0026quot;/;1h;1!H;${x;s/\\n/,/g;p}'\n开头和结尾加上引号 seq 10 | sed -n 's/^/\u0026quot;/;s/$/\u0026quot;/;p' 每处理一行不输出，追加到保持空间（hold space）， 处理到最后1行时，打印输出 seq 10 | sed -n 's/^/\u0026quot;/;s/$/\u0026quot;/;H;${x;p}' 解决输出空行问题： 第一次加入保持空间时，使用覆盖方式，后边使用追加方式 seq 10 | sed -n 's/^/\u0026quot;/;s/$/\u0026quot;/;1h;1!H;${x;p}' 把换行替换成空格， 搞定！ seq 10 | sed -n 's/^/\u0026quot;/;s/$/\u0026quot;/;1h;1!H;${x;s/\\n/,/g;p}' 2.3 awk 用法介绍 简介 AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。\n名次解释\n记录： 一行称为一条记录， 用$0表示 分隔符： 默认是空格和制表符，可指定 字段： 一条记录用分隔符分割开来的部分称为字段， 用$1,$2...$n表示 语法： awk [-Fvf] 'BEGIN{} [pattern] {} END{}' fileName\n注意 必须使用单引号包裹 BEGIN`` END 必须大写(它们是预定义好的、特殊的pattern) 参数含义 -F 指定分隔符，支持正则，可指定多个分隔符 例如： -F \u0026quot;[ ,]\u0026quot; 指定空格和逗号作分隔符 -v 指定变量 例如： -v FS=\u0026quot;[ ,]\u0026quot; 指定空格和逗号作分隔符 -f指定脚本文件 BEGIN{} 执行前的语句块 可以预定义变量，BEGIN{FS=\u0026quot;[ ,]\u0026quot;} 指定空格和逗号作分隔符 [pattern]{} 执行中的语句块 对 [pattern]匹配的行，执行{}中的语句 [pattern] 匹配筛选条件 使用 关系、逻辑、匹配或不匹配 运算符 为空代表不筛选 END{} 执行后的语句块 awk是一种文本处理语言， 支持 变量，运算符、表达式、流程控制、函数 等\n运算符\n赋值运算符： = += -= *= /= %= ^= **= 关系运算符： \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= != == 逻辑运算符： \u0026amp;\u0026amp; || ! 匹配运算符： ~ !~ 空格 ： 字符串连接 流程控制\n常用系统变量\nFS 字段分隔符，默认空格 OFS 输出字段分隔符，默认空格 RS 记录分隔符，默认\\n ORS 输出记录分隔符， 默认是\\n NF 一行的字段数 NR 当前的所在的行数 内置函数示例\n自定义函数示例\nawk程序语法详见 awk用户手册man awk\n2.4 引言中awk命令解析 seq 10 | awk '{s=s\u0026quot;\\\u0026quot;\u0026quot;$0\u0026quot;\\\u0026quot;,\u0026quot;} END{sub(\u0026quot;.$\u0026quot;, \u0026quot;\u0026quot;, s);print s}'\n使用全局变量s（默认初始化为空字符串）, 拼接字符串 seq 10 | awk '{s=s\u0026quot;\\\u0026quot;\u0026quot;$0\u0026quot;\\\u0026quot;,\u0026quot;} END{print s}' 把最后一个字符替替换成空， sub是awk内置函数 seq 10 | awk '{s=s\u0026quot;\\\u0026quot;\u0026quot;$0\u0026quot;\\\u0026quot;,\u0026quot;} END{sub(\u0026quot;.$\u0026quot;, \u0026quot;\u0026quot;, s);print s}' 注：全局拼接这种方式效率较低，不建议使用。练习使用awk是可以的。 3. 实践应用 3.1 背景 由于某次线上故障，部分统计数据缺失，需要从日志中解析出缺失的数据\n3.2 目标 从日志中解析出：date, time, reviewChannelId, taskType, reviewer, elements数组长度\n日志示例 解析结果示例 2023-02-11,21:13:49,1006,130000,tom,1 3.3 分析 其他的字段都可以通过截取日志一部分得到， elements的长度没有打印，怎么得？\n答：elements数组长度 =\u0026quot;CreativeElementVo\u0026quot;关键词出现次数 =以\u0026quot;CreativeElementVo\u0026quot; 为分隔符所得字段数-1\n3.4 实践 脚本执行效果如下 formalLog.sh 脚本代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash fileName=$1 cat $fileName | while read line ; do # 预处理：截取需要的部分 subLine=$(echo $line | awk -F \u0026#39;@message|reasons=\u0026#39; \u0026#39;{print $2}\u0026#39;) # 获取：elements数组长度 elementCount=$(echo $subLine | awk -F \u0026#39;CreativeElementVo\u0026#39; \u0026#39;{print (NF-1)}\u0026#39;) # 获取：reviewChannelId，taskType，reviewer mess=$(echo $subLine | awk \\ -F \u0026#34;reviewChannelId=|, taskType=|, reviewer=|, reviewStatus=\u0026#34; \\ -v OFS=\u0026#39;,\u0026#39; \\ \u0026#39;{print $(NF-3),$(NF-2),$(NF-1)}\u0026#39;) # 获取时间 dt=$(echo $subLine | awk -F \u0026#34; \u0026#34; -v OFS=\u0026#39;,\u0026#39; \u0026#39;{print $3,$4}\u0026#39;) # 输出目标内容 echo $dt,$mess,$elementCount done ","date":"2023-11-25T08:59:58+08:00","permalink":"https://graduatehan.github.io/p/linux-shell-%E5%91%BD%E4%BB%A4-awksed/","title":"Linux Shell 命令—— awk、sed"},{"content":"1. 背景 工作中有遇到这样的问题： 服务的一个接口 A 依赖的第三方接口耗时不稳定，导致接口 A 耗时有时会较高。如何做能避免出现接口 A 耗时高且并发量大时候，不影响服务的其他接口？使用 Hystrix 的熔断机制是可以的。因为服务是使用 SpringBoot 框架开发的，能不能不引入额外框架，通过 SpringBoot 提供的特性解决上面的问题呢？可以！ 即应用 SpringBoot 异步处理机制—— DeferredResult 。\n2. DeferredResult 简介 DeferredResult 是 SpringBoot 中一种异步处理 HTTP 请求的方式，基于 Servlet 3.0 规范中的异步请求处理机制。它可以把请求处理委托给另外的线程，释放 Servlet 容器（如 Tomcat 容器、Undertow 容器等）线程。容器线程可以继续处理其他请求，从而可以有效提高服务吞吐量，提高服务性能。\n对背景中提到的问题，可以通过自定义线程池处理接口 A 的请求，做到 接口 A 和服务其他接口在线程池级别的隔离，避免相互影响。\n3. DeferredResult 应用实验 3.1 实验代码 请求处理 Service 如下，模拟 2s 的请求处理耗时\n1 2 3 4 5 6 7 8 9 10 11 @Service public class MyService { public String process() { try { // 模拟请求处理耗时 2s TimeUnit.SECONDS.sleep(2); } catch (Exception ignored) { } return \u0026#34;success\u0026#34;; } } 同步接口调用 Service 方法\n1 2 3 4 5 6 7 @Resource private MyService myService; @GetMapping(\u0026#34;/sync\u0026#34;) public String sync() { return myService.process(); } 使用 DeferredResult 的异步接口调用 Service 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @GetMapping(\u0026#34;/async\u0026#34;) public DeferredResult\u0026lt;String\u0026gt; async() { DeferredResult\u0026lt;String\u0026gt; deferredResult = new DeferredResult\u0026lt;\u0026gt;(); // 将请求处理委托给线程池 deferredProcess(executorService, myService::process, deferredResult, \u0026#34;asyncMethod\u0026#34;); return deferredResult; } /** * 异步处理 * @param executor 执行请求处理任务的线程池 * @param supplier 要执行的方法 * @param deferredResult deferredResult对象 * @param interfaceName 接口名，用于监控上报和日志打印 * @param \u0026lt;T\u0026gt; 执行方法的返回值泛型 */ public \u0026lt;T\u0026gt; void deferredProcess(ExecutorService executor, Supplier\u0026lt;T\u0026gt; supplier, DeferredResult\u0026lt;T\u0026gt; deferredResult, String interfaceName) { executor.submit(() -\u0026gt; { try { final long startTime = System.currentTimeMillis(); T result = supplier.get(); // 设置正常返回结果 deferredResult.setResult(result); logger.info(\u0026#34;{} spend {} ms\u0026#34;, interfaceName, System.currentTimeMillis() - startTime); } catch (Exception e) { logger.error(\u0026#34;{} error e:\u0026#34;, interfaceName, e); // 设置异常返回结果 deferredResult.setErrorResult(e.getMessage()); } }); } 3.2 手动单次调用 同步接口调用，耗时 2.023s\n服务日志：\n异步接口调用，耗时 2.034s\n服务日志：\n从日志第五列（线程名称）中可以看到，调用同步接口期间，Tomcat 容器线程一直在工作。 调用异步接口期间，Tomcat容器线程被释放。\n3.3 使用 Jmeter 压测 引入 没有逻辑的 alive 接口，测试请求高并发时，同步接口和异步接口对服务提供的其他接口的影响\n1 2 3 4 @GetMapping(\u0026#34;/alive\u0026#34;) public String alive() { return \u0026#34;alive\u0026#34;; } application.yaml 配置\n1 2 3 4 5 6 server: port: 8080 tomcat: max-threads: 10 # 设置 Tomcat 容器最大线程数 debug: true 设置对照实验：\n实验一：使用 50 个线程并发访问 sync 接口 200次，同时使用 50 个线程并发访问 alive 接口 200次\n实验二：使用 50 个线程并发访问 async 接口 200次，同时使用 50 个线程并发访问 alive 接口 200次\n各接口测试聚合报告如下：\n实验一 sync 接口测试聚合报告\n实验一 alive接口测试聚合报告\n实验二 async 接口测试聚合报告\n实验二 alive 接口测试聚合报告\n为了更加直观的展示结果，从聚合报告中选择平均耗时、最小耗时、最大耗时三个指标汇总如下：\n平均耗时（ms） 最小耗时（ms） 最大耗时（ms） 实验一 sync 接口 8668 2004 12047 实验一 alive 接口 8846 1 10051 实验二 async 接口 2020 2003 2046 实验二 alive 接口 45 0 149 可以看出，相同的请求量和并发量，异步接口的耗时表现明显优于同步接口，对服务其他接口的影响异步接口同样明显优于同步接口。异步接口在请求到达和返回结果时，毕竟也使用了 Tomcat 容器线程，所以并发量大时，对其他接口还是有影响，但影响明显小于同步接口的影响。\n4. DeferredResult 请求处理流程分析 一次 DeferredResult 接口调用日志如下：\n结合日志，分析 DeferredResult 请求处理如下：\n客户端发送请求到 DispatchServlet （日志第 1 行） 通过映射器处理器 HandlerMapping 找到对应的控制器 Controller 方法 （日志第 2 行） 反射调用控制器方法处理请求（日志第 3-4 行） 根据控制器方法返回值类型，调用相应的 ReturnValueHandler。通过代码调试可以看到，对于 DeferredResult 返回值类型，调用的 ReturnValueHandler 为 DeferredResultMethodReturnValueHandler DeferredResultMethodReturnValueHandler 中 handleReturnValue 方法 会获取 请求的 WebAsyncManager 并调用 WebAsyncManager 的 startDeferredResultProcessing 方法，开启异步处理。此时容器线程释放，但客户端请求链接没有释放（日志第 5 行） 自定义线程处理完请求后，调用 deferredResult 的 setResult 方法，setResult 方法 中会回调 在 WebAsyncManager 设置的 resultHandler 方法（日志第 7-9 行） resultHandler 方法会将请求结果存在 WebAsyncManager 的 concurrentResult 属性中，并重新触发 dispatch （此时 Tomcat 线程 已经和 之前请求使用Tomcat 线程 不是同一个了）。 请求再次进来时，WebAsyncManager 的 concurrentResult 属性中已经存在请求响应结果（日志第 11 行） 不再反射调用控制器方法，将响应结果返回给客户端 5. 总结 简单总结，SpringBoot 的 Controller 方法返回值如果为 DeferredResult 类型，则不会把返回值作为响应返回给调用方，容器线程会被释放，DeferredResult 设置结果后，设置的结果才会作为响应返回给调用方。\n实现原理为，每一次请求都对应一个唯一的 WebAsyncManager 对象，DeferredResult 的 setResult 方法调用后，响应结果缓存在了 WebAsyncManager 中，同时会再次触发 doDispatch 方法。再次触发请求时，发现 WebAsyncManager 已经存在响应结果，会直接返回响应结果。\n最后，感谢阅读，如果有写的不妥的地方，欢迎评论区批评指正。\n","date":"2023-11-25T08:59:58+08:00","permalink":"https://graduatehan.github.io/p/springboot-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-deferredresult/","title":"SpringBoot 异步处理—— DeferredResult"}]